#! /usr/bin/env python
'''
----------------------------------------------------------------------------

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>

2016 Thomas Lemmin
----------------------------------------------------------------------------
'''


import os
import sys
import re
import copy
import math
import numpy as np
import networkx as nx
from prody import *

SELF_BIN = os.path.dirname(os.path.realpath(sys.argv[0]))
#sys.path.insert(0, SELF_BIN + '/support')


#####################################################################################
#								Example												#
#####################################################################################
'''Example

import sys
sys.path.append(SELF_BIN)
import glycosylator as glc
topology, patches, atomnames_to_patch, structure, connect, connect_tree, pres_topology, dihedrals=glc.testIt()
residue=connect_tree.keys()[5]

glc.rotate_dihedral(residue, dihedrals[residue][0], 120, connect_tree)
glc.writePDB(structure, 'rotated_man9.pdb')
'''
#####################################################################################
#								Utils												#
#                       Test function                                               #
#####################################################################################

def testIt():
    """
    Loads all basics files needed to test glycosylator:
        structure:              3D model of mannose 9 structure (PDB)
        topology:               dictionary of CHARMM36 topology for glycans
        patches:                dictionary CHARMM36 patches for connecting glycans
        atomnames_to_patches:   dictionary describing patches used to connect two glycans units
        connect:                connectivity tree for a mannose 9  
        glycan_keys:            dictionary for connectivity tree 
        connect_tree:           connectivity tree for template mannose 9 (structure)
        parameters:             dictionary with CHARMM36 parameters for glycans
        pres_topology:          patches used to connect glycans: defines torsional angles
        dihedrals:              torsonal angles in structure
    """ 
    p = BioPDB.PDBParser(PERMISSIVE=1)
    structure_id = "man9"
    filename = SELF_BIN + 'inputs/man9.pdb'
    structure = p.get_structure(structure_id, filename)
    filename = SELF_BIN + 'toppar_charmm/mannose.rtf'
    topology, patches, atomnames_to_patch = read_topology(filename)
    parameters = read_parameters(SELF_BIN + 'toppar_charmm/mannose.prm')
    rootAtom = structure[0]['G'][(' ', 1, ' ')]['C1']
    connect = read_connectivity_topology(SELF_BIN + 'topology/man9.top')
    glycan_keys=build_keys(connect)
    connect_tree = assign_unit_id(structure, rootAtom, 2.0, atomnames_to_patch)
    pres_topology=read_patch_topology(SELF_BIN + 'topology/pres.top')
    dihedrals=define_dihedrals(structure, connect_tree, pres_topology)
    return topology, patches, atomnames_to_patch, structure, connect, glycan_keys, connect_tree, pres_topology, dihedrals

def testPatchBuild():
    return -1
    
def testDummyBuild():
    """Test the building of two NAG residue from scratch (DUMMY atoms)
        Returns BioPDB structure of di-NAG polymer
    """
    filename = SELF_BIN + 'toppar_charmm/mannose.rtf'
    topology, patches, atomnames_to_patch=read_topology(filename)
    filename = SELF_BIN + 'topology/DUMMY.top'
    topology, patches, atomnames_to_patch=read_topology(filename,topology, patches, atomnames_to_patch)
    parameters=read_parameters(SELF_BIN + 'toppar_charmm/mannose.prm')
    structure_builder=init_structure_builder(0, 'test', 'A', 'G1')
    structure=structure_builder.get_structure()
    chain=structure[0]['A']
    
    resname='NAG'
    NAG1,serial_number=build_from_DUMMY(chain, 'DUMMY', [[0, 0, 0], [0, 0, 1], [0, 1, 1]], 1, 1, resname, patches['DUMMY_MAN'], topology, parameters)
    missing_atoms,serial_number=add_missing_atoms(NAG1, serial_number, topology, parameters)
    build_missing_atom_coord(NAG1, missing_atoms, topology[resname]['IC'])
    writePDB(structure, 'test_NAG1.pdb')
    NAG2,serial_number=build_from_patch(NAG1, serial_number, 2, 'NAG', patches['14bb'], topology, parameters)
    missing_atoms,serial_number=add_missing_atoms(NAG2, serial_number, topology, parameters)
    build_missing_atom_coord(NAG2, missing_atoms, topology[resname]['IC'])
    apply_patch(NAG1, NAG2, patches['14bb'])
    writePDB(structure, 'test_NAG2.pdb')
    rootAtom = NAG1['C1']
    connect_tree = assign_unit_id(structure, rootAtom, 2.0, atomnames_to_patch)
    pres_topology=read_patch_topology(SELF_BIN + 'topology/pres.top')
    dihedrals=define_dihedrals(structure, connect_tree, pres_topology)
    phi=60
    for dihedral in dihedrals[NAG2]:
        rotate_all(NAG2, connect_tree, dihedral, phi)
        writePDB(structure, 'test_NAG2_rotated'+str(phi)	+'.pdb')
        phi+=60
    return structure

def testDihedrals():
    """Tests the rotation around torsional angles.
       Reads mannose 9 glycan polymer
       Rotates NAG - NAG by 60 degrees and saves it as test_rotated1.pdb
       Rotates NAG - BMA bny 120 degrees and saves it as test_rotated2.pdb
    """
    p= BioPDB.PDBParser(PERMISSIVE=1)
    structure_id = "man9"
    filename =SELF_BIN + 'inputs/man9.pdb'
    structure = p.get_structure(structure_id, filename)
    filename = SELF_BIN + 'toppar_charmm/mannose.rtf'
    topology, patches, atomnames_to_patch=read_topology(filename)
    parameters=read_parameters(SELF_BIN + 'toppar_charmm/mannose.prm')
    
    rootAtom = structure[0]['G'][(' ', 1, ' ')]['C1']
    connect_tree = assign_unit_id(structure, rootAtom, 2.0, atomnames_to_patch)
    pres_topology=read_patch_topology(SELF_BIN + 'topology/pres.top')
    dihedrals=define_dihedrals(structure, connect_tree, pres_topology)
    rot_residue=structure[0]['G'][(' ', 2, ' ')]
    dihedral=dihedrals[rot_residue][0]
    rotate_all(rot_residue, connect_tree, dihedral, 60)
    writePDB(structure, 'test_rotated1.pdb')
    rot_residue=structure[0]['G'][(' ', 3, ' ')]
    dihedral=dihedrals[rot_residue][0]
    rotate_all(rot_residue, connect_tree, dihedral, 120)
    writePDB(structure, 'test_rotated2.pdb')

def testBuildFromLibrary():
    """Builds glycan polymer form connectivity tree
        Not finished, so it does not work...
    """
    connect = read_connectivity_topology(SELF_BIN + 'topology/man9.top')
    
    filename = SELF_BIN + 'toppar_charmm/mannose.rtf'
    topology, patches, atomnames_to_patch=read_topology(filename)
    filename = SELF_BIN + 'topology/DUMMY.top'
    topology, patches, atomnames_to_patch=read_topology(filename,topology, patches, atomnames_to_patch)
    parameters=read_parameters(SELF_BIN + 'toppar_charmm/mannose.prm')
    
    structure_builder=init_structure_builder(0, 'test', 'A', 'G1')
    structure=structure_builder.get_structure()
    chain=structure[0]['A']
    
    
    #for 
    resname='NAG'
    NAG1,serial_number=build_from_DUMMY(chain, 'DUMMY', [[0, 0, 0], [0, 0, 1], [0, 1, 1]], 1, 1, resname, patches['DUMMY_MAN'], topology, parameters)
    missing_atoms,serial_number=add_missing_atoms(NAG1, serial_number, topology, parameters)
    build_missing_atom_coord(NAG1, missing_atoms, topology[resname]['IC'])
    writePDB(structure, 'test_NAG1.pdb')
    NAG2,serial_number=build_from_patch(NAG1, serial_number, 2, 'NAG', patches['14bb'], topology, parameters)
    missing_atoms,serial_number=add_missing_atoms(NAG2, serial_number, topology, parameters)
    build_missing_atom_coord(NAG2, missing_atoms, topology[resname]['IC'])
    apply_patch(NAG1, NAG2, patches['14bb'])



#####################################################################################
#						Topology/Parameter readers									#
#####################################################################################

def readLinesFromFile(fileName):
    """Reads all lines in a file
    Parameters:
        fileName: path to file
    Returns:
        lines: list with all the lines in a file
    """
    file = open(fileName,'r') 				 # open the file
    lines = file.readlines() 				 # read all the lines in the file to the list "lines"
    file.close() 						         # close the file
    return lines

class CHARMMTopology:
    """
    Class for parsing and storing CHARMM topology files.
    
    """
    def __init__(self, fileIn):
         self.topology = {}
         self.patches = {}
         self.atomnames_to_patch = {}
         self.read_topology(fileIn)
    
    def reset(self):
        """Resets previsously read topology
        """
        self.topology = {}
        self.patches = {}
        self.atomnames_to_patch = {}
        
    def read_topology(self, fileIn):
        """Reads CHARMM topology file. 
        Parameters:
            fileIn: path to topology file
        Initialize:
            topology: dictionary storing topology (RES)
                        key: resname
                        value: dictionary with ATOM, BOND, CHARGE and IC
                        key: MASS contains all masses of atoms in topology
            patches: dictionary storing patches (PRES)
                        key: patchname
                        value: dictionary with dele, ATOM, BOND, CHARGE and IC
            atomnames_to_patch: dictionary storing patch name to connect two atoms
                        key: atom1-atom2
                        value: patchname
        """
        lines = readLinesFromFile(fileIn)
        topo_type=''
        residue={}
        masses={}
        for line in lines:                                                             # Loop through each line 
            line = line.split('\n')[0].split('!')[0].split() #remove comments and endl
            if line:
                if line[0]=='RESI' or line[0]=='PRES':
                    if residue:
                        if topo_type == 'RESI':
                            self.topology[resname] = copy.copy(residue)
                        elif topo_type == 'PRES':
                            self.patches[resname] = copy.copy(residue)
                            key = '-'.join(sorted([residue['BOND'][0][1:], residue['BOND'][1][1:]]))
                            #######TODO adapt for multiple patches#####
                            #if atomnames_to_patch.has_key(key):
                            #    atomnames_to_patch[key].append(resname)
                            #else:
                            #    atomnames_to_patch[key]=[resname]
                            ###########################################
                            self.atomnames_to_patch[key] = resname
                    residue['dele'] = []
                    residue['ATOM'] = []
                    residue['BOND'] = []
                    residue['IC'] = []    
                    topo_type = line[0]
                    resname = line[1]
                    residue['CHARGE'] = line[2] 
                elif line[0] == 'ATOM':
                    self.read_atom(line, residue)
                elif line[0] == 'BOND':
                    self.read_bond(line, residue)
                elif line[0] == 'IC':
                    self.read_ICs(line, residue)
                elif line[0] == 'dele':
                    self.read_dele(line, residue)
                elif line[0] == 'MASS':
                    self.read_mass(line, masses)
                    
        if topo_type == 'RESI': 
            self.topology[resname] = copy.copy(residue)
        elif topo_type == 'PRES':
            self.patches[resname] = copy.copy(residue)
            key = '-'.join(sorted([residue['BOND'][0][1:], residue['BOND'][1][1:]]))
            #if atomnames_to_patch.has_key(key):
            #    atomnames_to_patch[key].append(resname)
            #else:
            #    atomnames_to_patch[key]=[resname]
            self.atomnames_to_patch[key] = resname
        self.topology['MASS'] = copy.copy(masses)        

    def read_mass(self, mass, masses):
        mass[3]=float(mass[3])
        masses[mass[2]]=mass[3:]
         
    def read_atom(self, atom, residue):
        atom[3]=float(atom[3])
        residue['ATOM'].append(atom[1:])
        
    def read_dele(self, delatom, residue):
        residue['dele']+=(delatom[2:])    
        
    def read_bond(self, bond, residue):
        residue['BOND']+=(bond[1:])
        
    def read_ICs(self, ic, residue):
        ic[5:]=map(float, ic[5:])
        residue['IC'].append(ic[1:])

    def get_IC(self, ics, atom):
        atom_ic = ([ic for ic in ics if ic[3]==atom])
        return atom_ic

    def get_atom_name(self, ATOM):
        names=[]
        for a in ATOM:
            names.append(a[0])
        return names


class CHARMMParameters:
    """
    Class for parsing and storing CHARMM parameters files.
    """
    def __init__(self, fileIn):
        self.parameters = {}
        self.read_parameters

    def read_parameters(fileIn):
        """Reads CHARMM parameter file. 
        Parameters:
            fileIn: path to parameter file
        Initializes:
            parameters: dictionary storing parameters
                keys: 'BONDS', 'ANGLES', 'DIHEDRALS', 'NONBONDED', 'IMPROPER', 'NBFIX', 'CMAP' and 'ATOMS'
                values: dictionary of parameters
                        BONDS: atom1-atom2                  ->  k0, d0
                        ANGLES: atom1-atom2-atom3           ->  k0, a0, kub, d0
                        DIHEDRALS: atom1-atom2-atom3-atom4  ->  k0, n, dela
                        NONBONDED: atom1                    ->  
                        IMPROPER: atom1-atom2-atom3-atom4   ->  
                        NBFIX: atom1-atom2                  ->
                        CMAP:
                        ATOM: atom1                         -> mass
        """
        lines = readLinesFromFile(fileIn)
        prm = {}
        prm_type = ''
        tags = ['BONDS', 'ANGLES', 'DIHEDRALS', 'NONBONDED', 'IMPROPER', 'NBFIX', 'CMAP', 'ATOMS']
        #initialize parameter dictionary
        for t in tags:
            if not t in self.parameters:
                self.parameters[t] = {}
        for line in lines:                                                             # Loop through each line 
            line = line.split('\n')[0].split('!')[0].split() #remove comments and endl
            if line:
                if line[0] in tags:
                    if prm:
                        if prm_type in self.parameters:
                            self.parameters[prm_type] = dict(self.parameters[prm_type].items() + prm.items()) 
                        else:
                         self.parameters[prm_type] = copy.copy(prm)
                    prm_type = line[0]
                    prm = {}
                    continue
                if prm_type:
                    eval('read_'+prm_type+'(line, prm)')
        self.parameters[prm_type] = copy.copy(prm)


    def read_BONDS(self, bond, prm):
        #    CC311D     NC2D1     320.00    1.430
        if len(bond)==4:
            prm['-'.join(bond[0:2])]=map(float, bond[2:])
        else:
            print "Invalid BOND: "+' '.join(bond)

    def read_ANGLES(self, angle, prm):
        #CT1            CC321        HCA2     33.430        110.10     !22.53     2.17900 
        if len(angle)==5 or len(angle)==7:
            prm['-'.join(angle[0:3])]=map(float, angle[3:])
        else:
            print "Invalid ANGLE: "+' '.join(angle)
            
    def read_DIHEDRALS(self, dihe, prm):
        #CC321C    OC3C61    CC311D    NC2D1        0.62    1        0.0
        if len(dihe)==7:
            key='-'.join(dihe[0:4])
            if key in prm:
                prm[key].append(map(float, dihe[4:]))
            else:
                prm[key]=map(float, dihe[4:])
        else:
            print "Invalid DIHEDRAL: "+' '.join(dihe)
            
    def read_IMPROPER(self, impr, prm):
        #NC2D1     CC2O1     CC311D    HCP1        20.00    0     0.00
        if len(impr)==7:
            prm['-'.join(impr[0:4])]=map(float, impr[4:])
        else:
            print "Invalid IMPROPER: "+' '.join(impr)

    def read_NONBONDED(self, vdw, prm):
        #CT3            0.0             -0.0780        2.040 ! 0.0 -0.01 1.9 ! alkane, 4/98, yin, adm jr.
        if len(vdw)==4 or len(vdw)==7:
            prm[vdw[0]]=map(float, vdw[1:])
        else:
            print "Invalid NONBONDED: "+' '.join(vdw)
            
    def read_NBFIX(self, nb, prm):
        #SOD        OCL            -0.07502        3.23
        if len(nb)==4:
            prm['-'.join(nb[0:2])]=map(float, nb[2:])
        else:
            print "Invalid NBFIX: "+' '.join(nb)
            
    def read_CMAP(self, cmap, prm):
        return -1
        
    def read_ATOMS(self, atom, prm):
        #MASS        31 H            1.00800
        if len(atom)==4:
            prm[atom[2]]=float(atom[3])
        else:
            print "Invalid ATOM/MASS: "+' '.join(atom)



#####################################################################################
#						Biopython builder/writer									#
#####################################################################################
class Molecule:
    """
    Class for initializing a new molecule
    """
    def __init__(self, name, chain, segn):
        """initialize AtomGroup used to build pdb from scratch
        Parameters:
            name: structure name (str)
            chain: chain id (str)
            segn: segname (str)
        Initializes:
            molecule: AtomGroup 
            bonds: list of all bonds
            angles: list of all angles
            dihedrals: list of all dihedrals
            connectivity: graph for connectivity of molecule (bonds)
            directed_connectivity: directed acyclique graph of molecule 
        """
        self.molecule = AtomGroup(name)
        self.chain = chain
        self.segn = segn 
        self.bonds = []
        self.angles = []
        self.dihedrals = []
        self.connectivity = nx.Graph()
        self.directed_connectivity = nx.DiGraph()

    def writePDB(self, filename, selection = 'all'):
        """Saves molecule to a PDB file
        Parameters:
            filename: path to PDB file
            selection: selection of a subset of the molecule (str)
        """
        writePDB(filename, self.molecule.select(selection))

   def read_molecule_from_PDB(self, filename, **kwargs):
        """Initialize molecule from a PDB file
        Parameters:
            filename: path to PDB file
            **kwargs: any of the following which allows the selection of a subset of the PDB file
                subset: selection of a subset of the PDB file
                model: model number (int)
                chain: chain id (str)
        Initializes:
            molecule
            chain: chain id
            segn: segment name
            connectivity: bonds, angles, dihedrals and graph 
        """
        PDBmolecule = parsePDB(filename, **kwargs)
        chain = set(PDBmolecule.getChids())
        segn= set(PDBmolecule.getSegments())
        if len(chain) == 1 and len(segn) == 1:
            self.molecule = PDBmolecule
            self.chain = chain
            self.segn = segn
            self.update_connectivity()
        else:
            print "several chains are present in PDB. Please select only one molecule"
    
    
    def update_connecrtivity(self):
        """Updates all the connectivity (bond, angles, dihedrals and graphs)
        """
        self.guess_bonds()
        self.guess_angles()
        self.guess_dihdreals()
        self.updated_graphs()

    def guess_bonds(self, bond_length = 1.6):
        """Searches for all bonds in molecule
        Parameters:
            bond_length: maximum distance between two connected atoms (Angstrom)
        """
        self.connectivity = nx.Graph()
        for a in self.molecule:
            bonds = []
            for aa in self.molecule.select('wihtin ' + str(bond_length) + 'of serial' + str(a.getSerial()):
                    bonds.append(set(a.getSerial(), aa.getSerial()))
            self.connecitivity.add_edges_from(bonds)
        self.bonds = self.connectivity.edges()
            

    def guess_angles(self):
        """Searches for all angles in a molecule based on the connectivity
        """
        self.angles = []
        for node in self.connectivity.nodes():
            self.angles.extend(self.find_paths(self.connectivity, node, 2)


    def guess_dihedrals(self):
        """Searches for all dihedrals in a molecule based on the connectivity
        """
        self.dihedrals = []
        for node in self.connectivity.nodes():
            self.dihedrals.extend(self.find_paths(self.connectivity, node, 3)
        
    def find_paths(self, G, node, length, excludeSet = None):
        """Finds all paths of a given length
        Parameters:
            G: graph (netwrokx)
            node: starting node
            length: length of path
            excludedSet: set
        Returns:
            paths: list of all paths of a length starting from node 
        """
        if excludeSet == None:
            excludeSet = set([node])
        else:
            excludeSet.add(node)
          
        if n==0:
            return [[node]]
        paths = [[node]+path for neighbor in G.neighbors(node) if neighbor not in excludeSet for path in find_paths(G, neighbor, length-1, excludeSet)]
        excludeSet.remove(node)
        return paths

    def update_graphs(self):
        """Updates connectivity and directed graphs.
            - seaches for all cycles in connectivity graph
            - rebuilts acyclique directed graph 
        """
        cycles = nx.cycle_basis(self.connectivity, 1)
        #flatten cycles
        self.directed_graph = nx.Digraph()
        for node in self.connectivity.nodes():
            cycle = [cycle for cycle in cycles if node in cycle][0]
            if cycle:
                key = '-'.map(cycle, str)
                self.directed_graph.add_node(key, cycle_id = cycle)
            else:
                pass

    def add_residue_to_molecule(self, resid, resname, patch, linking_residue):
        """Add a new residue to molecule and updates all the connectivity (bond, angles, dihedrals and graphs)
        Parameters:
            resid: residue number (int)
            resame: name of residue (str)
            patch: patch to use to connect new residue (str)
            linking_residue: residue in molecule which will be linked to new residue
        """
        self.molecule += new_residue
        self.update_connectivity()

    #####################################################################################
    #								Builders											#
    #####################################################################################
class MoleculeBuilder:
    def __init__(self, Topo):
    """
    Parameters:
        Topo:  topology object used for building molecules
    """
        self.Topology = Topo
        
    def new_residue(self, resid, resname):
        """Initializes a residue from scratch
        Parameters:
            resid: residue id (int)
            resname: name of residue (str)
        Returns:
            residue: AtomGroup with all atoms initialized (from Topology)
            atoms_name: name of of all the atoms in residue
        """
        residue = AtomGroup(resname+str(resid))
        # add all the atoms
        atoms = self.Topology.get_atoms(resname)
        natoms = len(atoms)
        coords = np.zeros((natoms,3))
        residue.setCoords(coords)
        resn = []
        resi = []
        atoms_name = []
        chid = []
        segn = []
        occupancy = []
        beta = []
        i = 0
        serial = []
        element = []
        icode = []
        altloc = []
        for a in atoms:
            atoms_name.append(a[0])
            resn.append(resname)
            resi.append(resid)
            chid.append(self.chain)
            segn.append(sel.segn)
            occupancy.append(1)
            beta.append(0)
            serial.append(i)
            i += 1
            icode.append('')
            element.append(a[0][0])
            altloc.append('')
        residue.setNames(atoms_name)
        residue.setResnums(resi)
        residue.setResnames(resn)
        residue.setChids(chid)
        residue.setSegnames(segn)
        residue.setOccupancies(occupancy)
        residue.setBetas(beta)
        residue.setSerials(serial)
        residue.setIcodes(icode)
        residue.setElements(element)
        residue.setAltlocs(altloc)
        return residue,atoms_name


    def build_residue_to_molecule(self, resid, resname, patch, linking_residue):
        """Add a new residue to molecule 
        Parameters:
            resid: residue number (int)
            resame: name of residue (str)
            patch: patch to use to connect new residue (str)
            linking_residue: residue in molecule which will be linked to new residue
        """
        new_residue = self.new_residue(resid, resname)
        self.buildXXXX
        return new_residue

    def build_IC_graph(self, atoms, ics):
        """Extracts ICs to build missing atoms
        Parameters:
            atoms: list of missing atoms
            ics: list of internal coordinates
        Returns:
            unsorted_graph: dictionay representation of dependency of ics
                            key: atom name
                            value: list of atoms connected to key
            required_atoms: list atoms required to build missing atoms
        """
        unsorted_graph = {}
        required_atoms = []
        atomsIC = [atom.replace('*', '') for ic in ics for atom in ic[0:4]]
        #Build graph
        for a in atoms:
            if a in atomsIC:
                required_atoms.append(a)
                if not a in unsorted_graph:
                    unsorted_graph[a] = []
                for ic in get_IC(ics, a):
                    for aic in ic[0:3]:
                     aic=aic.replace('*', '')
                     if aic in unsorted_graph:
                         unsorted_graph[aic].append(a)
                     else:
                         unsorted_graph[aic] = [a]
        return unsorted_graph,required_atoms

    def topological_sort(self, unsorted_graph):
        """Topological sorting of a graph 
        Parameters:
            unsorted_graph: dictionary representation of a graph
        Returns:
            sorted_graph: list of nodes and corresponding edges
        """
        sorted_graph = []
        #sort graph
        while unsorted_graph:
            acyclic = False
            for node, edges in unsorted_graph.items():
                for edge in edges:
                    if edge in unsorted_graph:
                        break
                else:
                    acyclic = True
                    del unsorted_graph[node]
                    sorted_graph.append((node, edges))

            if not acyclic:
                print "WARNING! Cyclique dependency occurred in ICs. Impossible to build residue"
                print unsorted_graph
                print sorted_graph
                return ''
                break
        return sorted_graph[::-1]    
                
    def add_missing_atoms(self, residue, topology, parameters):
        """Add all missing atoms to a BIOPDB residue from topology
        Parameters:
            residue: BIOPDB residue
            topology: dictionary of topology (read_topology)
            parameters: dictionary of parameters (read_parameters)
        Retruns:
            missing_atoms: list of missing atom names
        """
        atomnames = topology[residue.get_resname()]['ATOM']
        missing_atoms = []
        for a in atomnames:
            if not a[0] in residue:
                vdw = 9
                element = ' '
                if a[1] in parameters['NONBONDED']: 
                    vdw = parameters['NONBONDED'][a[1]][2]
                if a[1] in topology['MASS']:
                    element = topology['MASS'][a[1]][1]
                residue.add(BioPDB.Atom.Atom(a[0], [9999.99, 9999.99, 9999.99], a[2], vdw, ' ', a[0], serial_number, element))
                missing_atoms.append(a[0])
                self.serial_number += self.serial_number
        return missing_atoms,serial_number

    def add_patch_atoms(self, residue, atomnames, topology, parameters):
        """Add all missing atoms to a BIOPDB residue from patch
        Parameters:
            residue: BIOPDB residue
            serial_number: serial number of current last atom
            atomnames: 
            topology: dictionary of topology (read_topology)
            parameters: dictionary of parameters (read_parameters)
        Retruns:
            missing_atoms: list of missing atom names
        """
        atoms = topology[residue.get_resname()]['ATOM']
        missing_atoms = []
        
        for a in atoms:
            if a[0] in atomnames:
                if not a[0] in residue:
                    vdw = 9
                    element = 'C'
                    if a[1] in parameters['NONBONDED']: 
                        vdw = parameters['NONBONDED'][a[1]][2]
                    if a[1] in topology['MASS']:
                        element = topology['MASS'][a[1]][1]
                    residue.add(BioPDB.Atom.Atom(a[0], [9999.99, 9999.99, 9999.99], a[2], vdw, ' ', a[0], serial_number, element))
                    missing_atoms.append(a[0])
                    self.serial_number += self.serial_number
        return missing_atoms

    def build_from_patch(self, patchresidue, resid, resname, patch, topology, parameters):
        """Build residue from a patch
        Parameters:
            patchresidue:
            serial_number: serial number of the current last atom
            resid: residue number
            resname: residue name
            patch: dictionary of patch topology (read_topology)
            topology: dictionary of topology (read_topology)
            parameters: dictionary of parameters (read_parameters)
        Returns:
            denovo_residue: complete residue (BioPDB residue)
        """
        denovo_residue = BioPDB.Residue.Residue((' ', resid, ' '), resname, ' ')
        chain = patchresidue.get_parent()
        chain.add(denovo_residue)
        denovo_residue.set_parent(chain)
        ics = patch['IC']
        atoms = sorted(set([atom.replace('*', '')[1:] for ic in ics for atom in ic[0:4] if atom.replace('*', '')[0]=='2']))
        missing_atoms = self.add_patch_atoms(denovo_residue, atoms, topology, parameters)
        missing_atoms = ['2'+a for a in missing_atoms]
        self.build_patch_missing_atom_coord(patchresidue, denovo_residue, missing_atoms, ics)
        return denovo_residue

    def build_from_DUMMY(self, chain, dummy_resname, dummy_coords, resid, resname, patch, topology, parameters):
        """Builds residue from DUMMY atoms
        Parameters:
            chain: chain id (str)
            dummy_resname: 
            dummy_coords: coordinated of dummy atoms
            resid: residue id
            resname: residue name
            patch: dictionary for patch
            topology: dictionary for topology
            parameters: dictionary for parameters
        Returns:
            denovo_residue: complete residue (BioPDB residue)
        """
        dummy = BioPDB.Residue.Residue((' ', -1, ' '), dummy_resname, ' ')
        dummy.set_parent(chain)
        chain.add(dummy)
        atomnames = topology[dummy.get_resname()]['ATOM']
        counter = 0
        for a in atomnames:
            dummy.add(BioPDB.Atom.Atom(a[0], dummy_coords[counter], a[2], 0, ' ', a[0], counter, 'D'))
            counter += 1
        denovo_residue = self.build_from_patch(dummy, resid, resname, patch, topology, parameters)
        #remove dummy from structure
        chain.detach_child(dummy.get_id())
        dummy.detach_parent()
        del dummy
        return denovo_residue

    def build_patch_missing_atom_coord(self.patchresidue, residue, missing_atoms, ICs):
        """Builds 
        Parameters:
            patchresidue:
            residue:
            missing_atoms:
            ICs:
        """
        unsorted_graph,required_atoms = self.build_IC_graph(missing_atoms, ICs)
        sorted_graph = self.topological_sort(unsorted_graph)
        atoms=[g[0] for g in sorted_graph if g[0] in required_atoms]

        for a in atoms:
            atomname = a[1:]
            atom = residue[atomname]
            ic = get_IC(ICs, a)
            if ic:
                ic = ic[0]
                c = 0
                for atom_ic in ic[0:4]:
                    if atom_ic.replace('*', '')[0]=='2':
                        exec('xa'+ str(c) +'=residue[atom_ic.replace(\'*\', \'\')[1:]].get_vector()')        
                    else:
                        exec('xa'+ str(c) +' = patchresidue[atom_ic.replace(\'*\', \'\')[1:]].get_vector()')
                    c += 1
                atom.set_coord(self.build_cartesian(xa0, xa1, xa2, ic[8], ic[7], ic[6]))

    def build_missing_atom_coord(self, residue, missing_atoms, ICs):
        """Builds
            Parameters:
                residue
                missing_atoms
                ICs
        """
        unsorted_graph,required_atoms = self.build_IC_graph(missing_atoms, ICs)
        sorted_graph = self.topological_sort(unsorted_graph)
        atoms=[g[0] for g in sorted_graph if g[0] in required_atoms]
        for a in atoms:
            atom = residue[a]
            atomname = atom.get_name()
            ic = get_IC(ICs, atomname)
            if ic:
                ic = ic[0]
                xa1 = residue[ic[0]].get_vector()
                xa2 = residue[ic[1]].get_vector()
                xa3 = residue[ic[2].replace('*', '')].get_vector()
                atom.set_coord(self.build_cartesian(xa1, xa2, xa3, ic[8], ic[7], ic[6]))    

    def build_cartesian(self, a1, a2, a3, r, theta, phi):
        """Builds missing atom from internal coordinates
            Parameters:
                a1: coordinates of atom1
                a2: coordinates of atom2
                a3: coordinates of atom3
                r: distance from atom3
                theta: angle between a2 a3 and missing atom
                phi: torsional angle formed by a1, a2, a3 and missing atom
            Returns:
                coordinates of missing atom
        """

        theta = np.radians(theta)
        phi  = np.radians(phi)
        cost = np.cos(theta)
        sint = np.sin(theta)
        cosp = np.cos(phi)
        sinp = np.sin(phi)
        rjk = a2 - a3
        rjk /= np.linalg.norm(rjk)
        rij = a1 - a2
        cross = np.cross(rij, rjk)
        cross /= np.linalg.norm(cross)
        cross2 = np.cross(rjk, cross)
        cross2 /= np.linalg.norm(cross2)
        wt = [r * cost, r * sint * cosp, r * sint * sinp]
        newc = rjk*wt[0] + cross2*wt[1] + cross*wt[2]
        return a3 + newc

#####################################################################################
#								Connectivity										#
#####################################################################################
class Glycosylator:
    def __init__(self):

    def read_connectivity_topology(self, fileName):
        """Read 
            Parameter:
                fileName: path to connectivity file
            Returns:
                connect_topology: dictionary of 
        """
        lines=readLinesFromFile(fileName)
        residue={}
        connect_topology={}
        nbr_units=0
        for line in lines:                                                             # Loop through each line 
            line=line.split('\n')[0].split('!')[0].split() #remove comments and endl
            if line:
                if line[0]=='RESI':	
                    if residue:
                            residue['#UNIT']=nbr_units
                            connect_topology[resname]=copy.copy(residue)
                    residue['UNIT']=[]
                    resname=line[1]
                    nbr_units=0
                elif line[0]=='UNIT':
                    read_unit(line, residue)
                    nbr_units+=1
        residue['#UNIT']=nbr_units
        connect_topology[resname]=copy.copy(residue)
        return connect_topology

    def build_keys(self, connect_topology):
        glycan_keys={}
        for res in connect_topology:
            key=[r[0]+' '+' '.join(r[2]) for r in connect_topology[res]['UNIT']]
            glycan_keys[res]=key
        return glycan_keys

    def read_unit(self, unit, residue):
        if len(unit)>2:
            residue['UNIT'].append([unit[1], unit[2], unit[3:]])
        else:
            residue['UNIT'].append([unit[1], [], []])
    
    def write_connectivity_topology(self, connect_tree, glycan_name, fileName):
        """Write connectivity tree of a glycan
            Parameters:
                connect_tree: dictionary of connections
                glycan_name: name of glycan (str)
                fileName: path to output file (str)
        """
        file=open(fileName,'w') 				 # open the file
        file.write('RESI ' + glycan_name + '\n')
        units=connect_tree.items()
        units.sort(key=lambda id:len(id[1]))
        for unit in units:
            file.write('UNIT '+unit[0].get_resname()+' C1 '+unit[1]+'\n')
        file.close() 
    
    def assign_unit_id(self, entry, rootAtom, bond_length, atomnames_to_patch):
        """Identify glycan based on connectivity
            Parameters:
                entry: BioPDB structure
                rootAtom: first atom of the glycan polymer (BioPDB Atom)
                bond_length: threshold for bond length (float)
                atomsnames_to_patch: dictionary of connecting atoms to patch (read_topology)
            Returns:
                connect_tree: dictionary of connections
        """
        connectivity=find_interresidue_bond(entry, bond_length, atomnames_to_patch)
        connect_tree={}
        connect_tree=build_connectivity_tree(rootAtom, connectivity, connect_tree)
        connect_tree[rootAtom.get_parent()]=''
        connect_tree.items().sort(key=lambda id:len(id[1]))
        return connect_tree
    

    def build_connectivity_tree(self, rootAtom, connectivity, connect_tree={}):
        """Defines the connectivity within a glycan polymer
            Parameters:
                rootAtom: first atom of the glycan polymer (BioPDB Atom)
                connectivity: 
                connect_tree: dictionary of glycan connectivity
            Returns:
                connect_tree: dictionary of glycan connectivity
        """
        while 1:
            rootResidue=rootAtom.get_parent()
            connect_idx=[i for i, item in enumerate(connectivity) if (rootResidue in item and not rootAtom in item)]
            #Remove all visited unit
            connect_idx=[idx for idx in connect_idx if not (connectivity[idx][0] in connect_tree and connectivity[idx][2] in connect_tree)]
            if not connect_idx:
                break
            branch=0
            for idx in connect_idx:
                if connectivity[idx][0]!=rootResidue:
                    connectResidue=connectivity[idx][0]
                    connectAtom=connectivity[idx][1]
                else:
                    connectResidue=connectivity[idx][2]
                    connectAtom=connectivity[idx][3]
                if rootResidue in connect_tree:
                    connect_tree[connectResidue]=connect_tree[rootResidue] + ' ' + connectivity[idx][-1]
                else:
                    connect_tree[connectResidue]=connectivity[idx][-1]
                if branch:
                    build_connectivity_tree(connectAtom, connectivity, connect_tree)
                else:
                    if connectivity[idx][0]!=rootResidue:
                        newrootAtom=connectivity[idx][1]
                    else:
                        newrootAtom=connectivity[idx][3]
                    branch=1
            rootAtom=newrootAtom
        return connect_tree 

    def find_patch(self, atom1, atom2, atomnames_to_patch):
        key='-'.join(sorted([atom1.get_name(), atom2.get_name()]))
        if key in atomnames_to_patch:
            return atomnames_to_patch[key]
        else:
             return ''
        
        return 

    def apply_patches(self):
        return -1

    def apply_patch(self, residue1, residue2, patch):
        """Removed atoms when apply a patch
            Parameters:
                residue1: first atom in the patch
                residue2: second atom in the patch
                patch: dictionary of patch
        """
        for a in patch['dele']:
            if a[0]=='1':
                if hasAtom(residue1, a[1:]):
                    residue1.detach_child(a[1:])
            else:
                if hasAtom(residue2, a[1:]):
                    residue2.detach_child(a[1:])
        return -1
        
        
    def identify_glycan(self, connect_tree, glycan_keys):
        """Identify glycan polymer
            Parameters:
                connect_tree:
                glycan_keys:
            Returns:
                gk: glycan name (empty string if unknown)
        """
        target=[]
        for r in connect_tree.keys():
            target.append(r.get_resname()+' '+connect_tree[r])
        len_target=len(target)
        for gk in glycan_keys:
                if len(set(target) & set(glycan_keys[gk]))==len_target and len(set(glycan_keys[gk]))==len_target:
                    return gk
        print 'Unknown glycan'
        return ''
     

    def mutate_glycan(self):
        return -1



def find_all_neighbors_atom(atom_list, radius):
    ns=BioPDB.NeighborSearch(atom_list)
    return ns.search_all(radius)

def find_all_neighbors(entry, radius):
    atom_list=BioPDB.Selection.unfold_entities(entry,'A')
    ns=BioPDB.NeighborSearch(atom_list)
    return ns.search_all(radius)
    
def find_neighbors(entry, center, radius):
    atom_list=BioPDB.Selection.unfold_entities(entry,'A')
    ns=BioPDB.NeighborSearch(atom_list)
    return ns.search(center,radius)

def find_interresidue_bond(entry, bond_length, atomnames_to_patch):
    neighbor_list=find_all_neighbors(entry, bond_length)
    bonds=[]
    for [a1, a2] in neighbor_list:
        if a1.get_parent() != a2.get_parent():
            patchname=find_patch(a1, a2, atomnames_to_patch)
            if patchname!='':
                bonds.append([a1.get_parent(), a1, a2.get_parent(), a2, patchname])
    return bonds

def generate_topology(entry):
    neighbor_list = find_all_neighbors(entry, radius)
    bondlist={}
    for [a1, a2] in neighbor_list:
        bondlist[a1]+=a1
        bondlist[a2]+=a2
    return bondlist

def find_RootAtom(entry, atom_linked, bondlength):
    neighbor_list=find_neighbors(entry, atom_linked.coord, bondlength)
    RootAtom=[]
    for [a1, a2] in neighbor_list:
        if a1.get_parent() != a2.get_parent():
            patchname=find_patch(a1, a2, atomnames_to_patch)
            if patchname!='':
                RootAtom.append([a1.get_parent(), a1, a2.get_parent(), a2, patchname])
    return RootAtom

#####################################################################################
#									Rotamers										#
#####################################################################################

def read_patch_topology (fileName):
    """Reads topology for inter molecule torsional. 
        Parameter:
            fileName: path to topology file
        Returns:
            pres_topology: dictionary of patch topology
                key: connectivity type
                value: dictionary of 
                        DIHE: atom names composing torsional angles
                        RES: residue name of connected glycans 
    """
    lines=readLinesFromFile(fileName)
    residue={}
    pres_topology={}
    for line in lines:
        line=line.split('\n')[0].split('!')[0].split() #remove comments and endl
        if line:
            if line[0]=='PRES':	
                if residue:
                        pres_topology[resname]=copy.copy(residue)
                residue['DIHE']=[]
                residue['RES']=[]
                resname=line[1]
            elif line[0]=='DIHE':
                read_dihe(line, residue)
            elif line[0]=='RES':
                read_res(line, residue)
    pres_topology[resname]=copy.copy(residue)
    return pres_topology

def read_dihe(dihe, residue):
    residue['DIHE'].append(dihe[1:])
    
def read_res(res, residue):
    residue['RES'].append(res[1:])

def define_dihedrals(entry, connect_tree, pres_topology):
    """
        Parameters:
            entry: BioPDB sturucture of glycan polymer
            connect_tree: dictionary
            pres_topology: dictionary of torsional angles for
        Returns:
            dihedrals:
    """
    inv_connect_tree = {v: k for k, v in connect_tree.items()}
    dihedrals={}
    for residue, patches in connect_tree.iteritems():
        if not patches:
            continue
        dihedrals[residue]=[]
        lpatches=patches.split()
        connectResidue=inv_connect_tree[' '.join(lpatches[:-1])]
        patch=lpatches[-1]
        dihe=pres_topology[patch]['DIHE']
        for d in dihe:
            dihe_atom=[]
            for a in d:
                if a[0]=="1":
                    if hasAtom(connectResidue, a[1:]):
                        dihe_atom.append(connectResidue[a[1:]])
                    else:
                        dihe_atom=[]
                        break
                else:
                    if hasAtom(residue, a[1:]):
                        dihe_atom.append(residue[a[1:]])
                    else:
                        dihe_atom=[]
                        break
            if dihe_atom:
                dihedrals[residue].append(dihe_atom)
    return dihedrals

def rotate_intra(dihedral, angle):
    atoms=[]
    for a in dihedral[4:]:
        atoms.append(a)
    rotate_dihedral(dihedral, angle, atoms)
    
    
def rotate_inter(rot_residue, connect_tree, dihedral, angle):
    patch=connect_tree[rot_residue]
    #search for all residue affected by rotation
    residues=[key for key, value in connect_tree.items() if re.search(patch+'*', value)]
    atoms=[]
    for r in residues:
        for a in r.child_list:
            atoms.append(a)
    rotate_dihedral(dihedral, angle, atoms)

def rotate_all(rot_residue, connect_tree, dihedral, angle):
    patch=connect_tree[rot_residue]
    #search for all residue affected by rotation
    residues=[key for key, value in connect_tree.items() if re.search(patch+'*', value)]
    atoms=[]
    for r in residues:
        for a in r.child_list:
            atoms.append(a)
    for a in dihedral[4:]:
        atoms.append(a)
    rotate_dihedral(dihedral, angle, atoms)

def rotate_dihedral(dihedral, angle, atoms):
    a1=dihedral[0].get_vector()
    a2=dihedral[1].get_vector()
    a3=dihedral[2].get_vector()
    a4=dihedral[3].get_vector()
    v=a3-a2
    #transform to radian
    angle=np.pi*angle/180.0
    delta_angle=angle-BioPDB.calc_dihedral(a1, a2, a3, a4)
    rot=BioPDB.rotaxis(delta_angle, v)
    for a in atoms:
        coord=a.get_vector()
        coord=coord-a3
        coord=coord.left_multiply(rot)
        a.set_coord(coord+a3)
 
#####################################################################################
#								Protein glycolysation								#
#####################################################################################
def build_polypetides(entry):
    ppb=BioPDB.PPBuilder()
    return ppb.build_peptides(entry)
    

def find_sequon(polypetide):
    seq=str(polypetide.get_sequence())
    glyc_asn=[m.start() for m in re.finditer('N\w[ST]', seq)]
    residues=[]
    for a in glyc_asn:
        residues.append(polypetide[a])
    return residues

def get_N_linked_glycosylation_residue(entry):
    polypetides=build_polypetides(entry)
    residues=[]
    for pp in polypetides:
        residues.append(find_sequon(pp))
    return residues
    
def find_N_linked_glycans(entry, patch, bondlength):
    residues=get_N_linked_glycosylation_residue(entry)
    N_glycans=[]
    for chain_res in residues:
        for res in chain_res:
            glycan=find_N_linked_glycan(res, entry, patch, bondlength)
            if glycan:
                N_glycans+=(glycan)
    return N_glycans

def find_N_linked_glycan(res, entry, patch, bondlength):
    if patch['BOND'][0][0]=='1':
        atom=patch['BOND'][0][1:]
        gatom=patch['BOND'][1][1:]
    else:
        atom=patch['BOND'][1][1:]
        gatom=patch['BOND'][0][1:]
    N_glycan=[]
    if not hasAtom(res, atom):
        return []
    neigh=find_neighbors(entry, res[atom].get_coord(), bondlength)
    for n in neigh:
        if n.get_id()==gatom:
            N_glycan.append([res, res[atom], n.get_parent(), n])
    return N_glycan

    
#####################################################################################
#                               build glycan                                        #
##################################################################################### 

def build_glycan_gaph(connect_tree):
    inv_connect_tree = {v: k for k, v in connect_tree.items()} 
    unsorted_graph={}
    for g in connect_tree:
        print g
        print connect_tree[g]
        if not g in unsorted_graph:
            unsorted_graph[g]=[]
        key=connect_tree[g]
        if not key:
            continue
        gr=inv_connect_tree[' '.join(key.split()[:-1])]
        print gr
        if gr in unsorted_graph:
            unsorted_graph[gr].append(g)
        else:
            unsorted_graph[gr]=[g]
    return unsorted_graph
 

def add_N_linked_glycan(Residue, patch_name, glycan, patches, topology, parameters):
    connect_tree={}
    inv_connect_tree={}
    structure_builder=init_structure_builder(0, 'glycan', 'G', 'G1')
    structure=structure_builder.get_structure()
    chain=structure[0]['G']
    linker=Residue.copy()
    chain.add(linker)
    serial_number=0
    resid= 1    
    for g in glycan:
        resname=g[0]
        if g[2]:
            previous_residue=inv_connect_tree[' '.join(g[2][:-1])]
            patch=g[2][-1]
        else:
            previous_residue=linker
            patch=patch_name
        glycan_unit,serial_number=build_from_patch(previous_residue, serial_number, resid, resname, patches[patch], topology, parameters)
        connect_tree[glycan_unit]=' '.join(g[2])
        inv_connect_tree[' '.join(g[2])]=glycan_unit
        missing_atoms,serial_number=add_missing_atoms(glycan_unit, serial_number, topology, parameters)
        build_missing_atom_coord(glycan_unit, missing_atoms, topology[resname]['IC'])
        apply_patch(previous_residue, glycan_unit, patches[patch])
        resid+=1
    return structure_builder

def mutate_N_linked_glycan(entry, Residue, patch_name, glycan, patches, topology, parameters, atomnames_to_patch):
    mutated_connect_tree={}
    mutated_inv_connect_tree={} 
    N_glycan=find_N_linked_glycan(Residue, entry, patches[patch_name], 2.5)
    connect_tree=assign_unit_id(entry, N_glycan[0][3], 2.5, atomnames_to_patch)
    inv_connect_tree = {v: k for k, v in connect_tree.items()}
    #build new glycan
    structure_builder=init_structure_builder(0, 'glycan', 'G', 'G1')
    structure=structure_builder.get_structure()
    chain=structure[0]['G']
    linker=Residue.copy()
    chain.add(linker)
    
    serial_number=0
    resid= 1
    for g in glycan:
        resname=g[0]
        key = ' '.join(g[2][:])
        if key in inv_connect_tree:
            glycan_copy=inv_connect_tree[key].copy()
            id=inv_connect_tree[key].get_id()
            idm=(id[0], resid, id[2])
            glycan_copy.id=idm
            chain.add(glycan_copy)
            mutated_connect_tree[glycan_copy]=' '.join(g[2])
            mutated_inv_connect_tree[' '.join(g[2])]=glycan_copy
            serial_number+=len(glycan_copy)
            resid+=1
            continue
        if g[2]:
            previous_residue=mutated_inv_connect_tree[' '.join(g[2][:-1])]
            patch=g[2][-1]
        else:
            previous_residue=linker
            patch=patch_name
        glycan_unit,serial_number=build_from_patch(previous_residue, serial_number, resid, resname, patches[patch], topology, parameters)
        mutated_connect_tree[glycan_unit]=' '.join(g[2])
        mutated_inv_connect_tree[' '.join(g[2])]=glycan_unit
        missing_atoms,serial_number=add_missing_atoms(glycan_unit, serial_number, topology, parameters)
        build_missing_atom_coord(glycan_unit, missing_atoms, topology[resname]['IC'])
        apply_patch(previous_residue, glycan_unit, patches[patch])
        resid+=1
    return structure_builder 

def detect_clashes(residues, threshold=1.0):
    atom_list=[]
    for r in residues:
         atom_list.append(r.get_list())
    neighbor_list=find_all_neighbors_atom(atom_list, threshold)
    return neighbor_list

def add_model(structure, model):
    model_copy=model.copy()
    model_copy.serial_num=len(structure)
    structure.add(model)
    return 0

def get_next_rotamer():
    return -1

def get_next_unit():
    return    -1

def backtracking_rotamer_search(current_residue, rotamer, residues, structure_builder):
    for r in rotamer:
        c=detect_clash(residues)
        if c:
            continue
        next_residue,next_rotamer=get_next_rotamer()
        if next_rotamer:
             if next_residue!=current_residue:
                 residues.append(next_residue)
             backtracking_rotamer_search(next_residue, next_rotamer, residues, structure_builder)
        else:
             add_model(structure_builder)
    residues.pop()
    return 0


def read_grid_search(filename):

    return -1

#def grid_search(strucutre, connect_tree, pres_toplogy):
# sorted_glycans=topological_sort(build_glycan_gaph(connect_tree))
# dihedrals=define_dihedrals(structure, connect_tree, pres_topology)
# for
